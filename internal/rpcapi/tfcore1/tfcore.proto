syntax = "proto3";
package tfcore1;

option go_package = "github.com/hashicorp/terraform/internal/rpcapi/tfcore1";

service Terraform {
    // OpenConfigCwd opens a new configuration by reading from the current
    // working directory of the RPC server process, in a similar way that
    // a "terraform validate" (or similar) CLI command would.
    //
    // This will succeed only if the working directory was already initialized
    // to contain local copies of any external modules the configuration
    // depends on, which would typically be achieved by running "terraform init"
    // prior to starting the RPC server.
    rpc OpenConfigCwd(OpenConfigCwd.Request) returns (OpenConfigCwd.Response);

    // CloseConfig discards a previously-opened configuration, invalidating
    // its configuration ID.
    //
    // Will return a "not found" error if the given configuration id doesn't
    // correspond with a currently-open configuration. If CloseConfig returns
    // successfully then the given configuration ID becomes invalid.
    rpc CloseConfig(CloseConfig.Request) returns (CloseConfig.Response);

    // ValidateConfig checks the given open configuration against both the
    // core language validation rules and any plugin-specified validation
    // rules.
    rpc ValidateConfig(ValidateConfig.Request) returns (ValidateConfig.Response);

    // CreatePlan calculates a new plan by comparing an open configuration with
    // a previous run state snapshot.
    rpc CreatePlan(CreatePlan.Request) returns (CreatePlan.Response);

    // DiscardPlan discards a plan currently cached in memory, which would've
    // been placed there either by CreatePlan or by ImportPlan.
    rpc DiscardPlan(DiscardPlan.Request) returns (DiscardPlan.Response);

    // ExportPlan returns an opaque blob serialization of a plan currently
    // cached in memory, which can be re-imported later -- possibly to another
    // RPC API instances as long as it's the same Terraform Core version and
    // working directory -- using ImportPlan.
    rpc ExportPlan(ExportPlan.Request) returns (ExportPlan.Response);

    // ImportPlan re-imports an opaque plan blob serialization previously
    // produced by ExportPlan on another RPC API instance connected to the
    // same working directory and Terraform Core version.
    rpc ImportPlan(ImportPlan.Request) returns (ImportPlan.Response);

    // ApplyPlan applies a previously-created plan to real infrastructure,
    // using provider operations, and returns the resulting new state snapshot,
    // which the caller should then save to use as the previous run state for
    // the next call to CreatePlan.
    rpc ApplyPlan(ApplyPlan.Request) returns (ApplyPlan.Response);
}

message OpenConfigCwd {
    message Request {
        // Intentionally empty, for now.
    }
    message Response {
        // An opaque identifier that will represent this configuration in
        // other RPC calls that require an open configuration.
        //
        // If the response also has error diagnostics then this will be unset
        // and should not be used.
        uint64 config_id = 1;

        // A set of diagnostics detected during configuration loading. This
        // will include only surface-level problems such as syntax errors,
        // and so the absense of diagnostics here does not necessarily mean
        // that the configuration is valid.
        repeated Diagnostic diagnostics = 2;
    }
}

message CloseConfig {
    message Request {
        uint64 config_id = 1;
    }
    message Response {
        // Intentionally empty, for now.
    }
}

message ValidateConfig {
    message Request {
        uint64 config_id = 1;
    }
    message Response {
        repeated Diagnostic diagnostics = 2;
    }
}

message CreatePlan {
    message Request {
        uint64 config_id = 1;
        bytes prev_run_state = 2;
        PlanOptions options = 3;
    }
    message Response {
        // Opaque unique id for an in-memory plan. The plan will be lost once
        // the RPC server exits, but callers can export it to use in a later
        // operation using the ExportPlan and ImportPlan operations.
        //
        // If plan_id is zero (unset) then the input was invalid or one of
        // the resource planning operations failed, and so there should be
        // error diagnostics explaining what went wrong. Zero is never a valid
        // plan id.
        uint64 plan_id = 1;
        repeated Diagnostic diagnostics = 2;

        // An approximation of the expected output values that should result
        // from applying this plan.
        //
        // Some of the planned output values might be unknown value
        // placeholders, if they are derived from resource instance attributes
        // that a provider won't know until the apply step.
        map<string, DynamicValue> planned_output_values = 3;
    }
}

message DiscardPlan {
    message Request {
        uint64 plan_id = 1;
    }
    message Response {
    }
}

message ExportPlan {
    message Request {
        uint64 plan_id = 1;
    }
    message Response {
        // An opaque serialization of the plan, which the caller
        // can store verbatim and then submit back to ImportPlan of a
        // subsequent RPC server of the same Terraform Core version
        // running against the same working directory.
        bytes raw_plan = 1;
    }
}

message ImportPlan {
    message Request {
        // An unmodified byte stream previously returned from a call
        // to ExportPlan, possibly from another RPC server instance but
        // still of the same Terraform Core version running against
        // the same working directory.
        bytes raw_plan = 1;
    }
    message Response {
        uint64 plan_id = 1;
    }
}

message ApplyPlan {
    message Request {
        uint64 plan_id = 1;
    }
    message Response {
        bytes new_state = 1;
        repeated Diagnostic diagnostics = 2;
    }
}

message PlanOptions {
    enum Mode {
        NORMAL = 0;
        REFRESH_ONLY = 1;
        DESTROY = 2;
    }
    Mode mode = 1;
    map<string, DynamicValue> variable_defs = 2;
    bool skip_refresh = 3;
    repeated AbsResourceInstance force_replace = 4;
}

enum ResourceMode {
    INVALID = 0;
    MANAGED = 1;
    DATA = 2;
}

message AbsResource {
    repeated ModuleInstanceStep module = 1;
    ResourceMode mode = 2;
    string type = 3;
    string name = 4;
}

message AbsResourceInstance {
    AbsResource resource = 1;
    InstanceKey key = 2;
}

message ModuleInstanceStep {
    string name = 1;
    InstanceKey key = 2;
}

message InstanceKey {
    // A totally unset InstanceKey represents the third possibility: no key at all
    oneof key {
        string string = 1;
        int64 int = 2;
    }
}

// DynamicValue represents an arbitrary value in the Terraform language type
// system, such as the value of an input variable or an output value.
message DynamicValue {
    bytes msgpack = 1;

    // Set to true if the value is considered sensitive, either because it
    // was explicitly declared as such or because it was derived from some
    // other value marked as sensitive.
    bool sensitive = 2;
}

message Diagnostic {
    enum Severity {
        INVALID = 0;
        ERROR = 1;
        WARNING = 2;
    }
    Severity severity = 1;
    string summary = 2;
    string detail = 3;
    string address = 4;
    SourceRange subject = 5;
    SourceRange context = 6;

    // Should we include the snippet in here too? That's tricky because it's
    // a CLI-view-level concern rather than a core-level concern, so we'll
    // consider that out of scope for now. Callers could calculate it themselves
    // based on "subject" and "context" anyway.
}

message SourceRange {
    message Pos {
        int64 line = 1;
        int64 column = 2;
        int64 byte = 3;
    }
    string filename = 1;
    Pos start = 2;
    Pos end = 3;
}
